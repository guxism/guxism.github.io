<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <title>Hacking Chevrotain to Parse Comments</title>
    <style>
      /*
! tailwindcss v3.2.1 | MIT License | https://tailwindcss.com
*//*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured `sans` font-family by default.
*/

html {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-tab-size: 4; /* 3 */
  -o-tab-size: 4;
     tab-size: 4; /* 3 */
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
*/

body {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured `mono` font family by default.
2. Correct the odd `em` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-size: 1em; /* 2 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent `sub` and `sup` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
[type='button'],
[type='reset'],
[type='submit'] {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to `inherit` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled {
  cursor: default;
}

/*
1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}
.container {
  width: 100%;
}
@media (min-width: 640px) {

  .container {
    max-width: 640px;
  }
}
@media (min-width: 768px) {

  .container {
    max-width: 768px;
  }
}
@media (min-width: 1024px) {

  .container {
    max-width: 1024px;
  }
}
@media (min-width: 1280px) {

  .container {
    max-width: 1280px;
  }
}
@media (min-width: 1536px) {

  .container {
    max-width: 1536px;
  }
}
.static {
  position: static;
}
.fixed {
  position: fixed;
}
.mt-5 {
  margin-top: 1.25rem;
}
.mt-2 {
  margin-top: 0.5rem;
}
.block {
  display: block;
}
.table {
  display: table;
}
.contents {
  display: contents;
}
.lowercase {
  text-transform: lowercase;
}
.shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
@font-face {
  font-family: "allerlight";
  src: url("/fonts/aller-light.woff") format("woff");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "imfell";
  src: url("/fonts/IMFellEnglish-Regular.ttf");
}
@font-face {
  font-family: "oswaldregular";
  src: url("/fonts/Oswald/static/Oswald-Regular.ttf") format("truetype");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "opensansregular";
  src: url("/fonts/Open_Sans/static/OpenSans/OpenSans-Regular.ttf") format("truetype");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "firacode";
  src: url("/fonts/Fira_Code/woff2/FiraCode-Regular.woff2") format("woff2"), url("/fonts/Fira_Code/woff/FiraCode-Regular.woff") format("woff");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "sysong";
  src: url("/fonts/SourceHanSerifSC-VF.otf.woff2") format("woff2");
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "syblack";
  src: url("/fonts/SourceHanSansSC-VF.otf.woff2") format("woff2");
  font-weight: 400;
  font-style: normal;
}
html,
body {
  height: 100%;
}

body {
  color: #252519;
  position: relative;
  min-height: 100%;
  min-width: 100%;
  margin: 0;
  padding: 0;
  font-family: opensansregular;
}

@media (min-width: 640px) {

  body {
    font-size: 0.875rem;
    line-height: 1.25rem;
  }
}

@media (min-width: 768px) {

  body {
    font-size: 1.125rem;
    line-height: 1.75rem;
  }
}

.container2 {
  font-family: opensansregular;
  margin-right: auto;
  margin-left: auto;
  width: 95%;
}
@media (min-width: 640px) {
  .container2 {
    width: 95%;
  }
}
@media (min-width: 768px) {
  .container2 {
    width: 95%;
  }
}
@media (min-width: 1024px) {
  .container2 {
    width: 95%;
  }
}
@media (min-width: 1280px) {
  .container2 {
    width: 60%;
  }
}
@media (min-width: 1536px) {
  .container2 {
    width: 60%;
  }
}

.site-head {
  margin-bottom: 0px;
  padding-top: 0.5rem;
  padding-bottom: 0px;
}

.site-navi {
  padding-top: 0px;
  margin-top: 0.25rem;
  margin-bottom: 0px;
  padding-bottom: 0px;
  display: flex;
  flex-wrap: wrap;
}
.site-navi .current-page {
  font-weight: 700;
}
.site-navi ul {
  margin: 0px;
  margin-bottom: 0px;
  gap: 5rem;
  padding: 0px;
  padding-bottom: 0px;
  vertical-align: middle;
}
.site-navi ul li {
  margin-bottom: 0px;
  display: inline-block;
  padding-right: 0.25rem;
}
.site-navi ul li .regards {
  display: none;
}
.site-navi .banner h1 {
  font-size: 1.875rem;
  line-height: 2.25rem;
}
@media (min-width: 768px) {

  .site-navi .banner h1 {
    font-size: 2.25rem;
    line-height: 2.5rem;
  }
}
@media (min-width: 1024px) {

  .site-navi .banner h1 {
    font-size: 3rem;
    line-height: 1;
  }
}

.post-tags ul {
  display: flex;
  flex-wrap: wrap;
  margin: 0px;
  gap: 0.5rem;
  padding: 0px;
}
.post-tags ul li {
  display: inline;
  margin-right: 0.25rem;
  font-size: 0.75rem;
  line-height: 1rem;
}
@media (min-width: 768px) {

  .post-tags ul li {
    font-size: 0.875rem;
    line-height: 1.25rem;
  }
}
.post-tags ul li .regards {
  display: none;
}

.content2 {
  display: block;
  margin-bottom: 1.25rem;
  margin-top: 0px;
  font-size: 1.5rem;
  line-height: 2rem;
}

@media (min-width: 768px) {

  .content2 {
    font-size: 1.25rem;
    line-height: 1.75rem;
  }
}

@media (min-width: 1024px) {

  .content2 {
    font-size: 0.875rem;
    line-height: 1.25rem;
  }
}
.content2 table {
  border-collapse: collapse;
  border: 3px solid black;
}
.content2 th,
.content2 td {
  border: 1px solid black;
}

.content-tail {
  margin-top: 0.5rem;
  margin-bottom: 0.75rem;
  font-size: 1.5rem;
  line-height: 2rem;
}

@media (min-width: 1024px) {

  .content-tail {
    font-size: 0.875rem;
    line-height: 1.25rem;
  }
}

ol,
ul {
  padding-left: 2rem;
}

ul {
  padding-left: 2.5rem;
  list-style-type: disc;
}

ol {
  padding-left: 2.5rem;
  list-style-type: decimal;
}

nav {
  padding-left: 0.5rem;
  --tw-bg-opacity: 1;
  background-color: rgb(249 250 251 / var(--tw-bg-opacity));
  margin-top: 1.25rem;
  margin-bottom: 1.25rem;
}
nav ol {
  list-style-type: decimal;
}

blockquote p {
  margin: 1.25rem;
  font-style: italic;
}

h1,
h2,
h3,
h4,
h5 {
  font-family: opensansregular;
  display: block;
  font-weight: 700;
  --tw-text-opacity: 1;
  color: rgb(55 65 81 / var(--tw-text-opacity));
  margin-top: 1.25rem;
}

.post-head {
  font-size: 0.875rem;
  line-height: 1.25rem;
  --tw-text-opacity: 1;
  color: rgb(75 85 99 / var(--tw-text-opacity));
}

.post-content h1 {
  margin-top: 1.25rem;
}

h1 {
  font-size: 2.25rem;
  line-height: 2.5rem;
  --tw-text-opacity: 1;
  color: rgb(0 0 0 / var(--tw-text-opacity));
}

h2 {
  font-size: 1.875rem;
  line-height: 2.25rem;
}

h3 {
  font-size: 1.5rem;
  line-height: 2rem;
}

h4 {
  font-size: 1.25rem;
  line-height: 1.75rem;
}

p {
  margin-top: 1.25rem;
  margin-bottom: 1.25rem;
}

li p {
  padding-left: 0px !important;
}

ol,
ul {
  max-width: 600px;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

p {
  width: 100%;
}

img {
  max-width: 600px;
  padding-left: 10px;
  margin-top: 1.25rem;
  margin-bottom: 1.25rem;
}

a {
  text-decoration-line: underline;
}

p code,
li code {
  background: #f8f8ff;
  border: 1px solid #dedede;
  padding: 0 0.2em;
  font-weight: 300h;
}

pre > code {
  clear: both;
  display: inline-block;
  margin-left: 0.75rem;
  margin: 0px;
  margin: auto;
  font-family: firacode;
  font-size: 0.875rem;
  line-height: 1.25rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
}

pre {
  white-space: pre-wrap;
  word-break: break-word;
  clear: both;
  margin-top: 1.25rem;
  margin-bottom: 1.25rem;
  padding-left: 0.25rem;
}

pre.one-piece {
  background: #eee;
  border-top: #bbb 1px solid;
  border-bottom: #bbb 1px solid;
}

pre.insert-before {
  background: #eee;
  border-top: #bbb 1px solid;
}
pre.insert-before code {
  color: #7a7a77;
}

pre.insert {
  background: #eee;
}
pre.insert code {
  font-weight: bolder;
}

pre.insert-after {
  background: #eee;
  border-bottom: #bbb 1px solid;
}
pre.insert-after code {
  color: #7a7a77;
}

.insert-before {
  margin-top: 1.25rem;
  margin-bottom: 0px;
}

.insert-after {
  margin-top: 0px;
  margin-bottom: 1.25rem;
}

.insert {
  margin-top: 0px;
  margin-bottom: 0px;
}

.envelope:before {
  content: "\f003";
}

footer {
  font-size: 0.875rem;
  line-height: 1.25rem;
}

.device:before {
  content: "unknown";
}
@media (min-width: 640px) {
  .device:before {
    content: "sm";
  }
}
@media (min-width: 768px) {
  .device:before {
    content: "md";
  }
}
@media (min-width: 1024px) {
  .device:before {
    content: "lg";
  }
}
@media (min-width: 1280px) {
  .device:before {
    content: "xl";
  }
}
@media (min-width: 1536px) {
  .device:before {
    content: "2xl";
  }
}

.table-of-blogs {
  margin-bottom: 0.75rem;
  margin-top: 0.75rem;
}
.table-of-blogs td.title {
  padding-left: 0.25rem;
}
.table-of-blogs .post-meta {
  display: flex;
  flex-wrap: wrap;
  --tw-text-opacity: 1;
  color: rgb(107 114 128 / var(--tw-text-opacity));
}
.table-of-blogs .recently-updated {
  cursor: help;
}
.table-of-blogs a {
  --tw-text-opacity: 1;
  color: rgb(29 78 216 / var(--tw-text-opacity));
  text-decoration-line: none;
}
.table-of-blogs a:visited {
  color: rgb(107 33 168 );
}
.table-of-blogs a:hover {
  --tw-text-opacity: 1;
  color: rgb(30 58 138 / var(--tw-text-opacity));
}
.table-of-blogs td {
  padding-left: 2rem;
}
    </style>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
  </head>
  <body>
    
    <div class="container2">
      <div class="site-head post-head">
      <div class="site-navi">
                <ul>
                 <li><a href="/">Home</a></li>
                <li><a href="/reading.html">Reading</a></li>
                 <li><a href="/users" class="regards">Log in</a></li>
                 <li><a href="/archives" class="regards">Archives</a></li>
                </ul>
        </div>
      </div>
      <div class="content2 post-content">
        <h1>Hacking Chevrotain to Parse Comments</h1>
        <nav class="table-of-contents"><ol><li><a href="#caveat-take-care-of-the-order-of-token-patterns">Caveat: take care of the order of token patterns</a></li><li><a href="#parsing-the-comment">Parsing the comment</a><ol><li><a href="#the-syntax-of-a-comment">The syntax of a comment</a></li><li><a href="#dont-skip-whitespaces">Don't skip whitespaces</a></li><li><a href="#skip-the-comments-first-add-them-back-later">Skip the comments first, add them back later</a></li><li><a href="#formatter">Formatter</a></li></ol></li></ol></nav><p>While I was writing Nginx configurations, it bothered me that there was no formatter that can handle the ansible templates for nginx .conf files properly, all those formatter I found resulted in further mess. So I decided to write one myself. I saw some projects archive that goal by handling the idents. In my option that is a fragile strategy only applies to source written by disciplined and organized minds, a tool should be prepared for the tests of all kinds of input. What I have to in mind is the method most consistent in every situation, that is to parse the source and interpret it into a new one. But I am not doing it bare handed, I use the parser library Chevrotain.</p>
<p>The nginx configuration syntax is simple, one can parse it within 100 lines of code, problem is I am writing a formatter, which must preserve the comments of the source. Discarding comments the same way as treating whitespace is perfectly reasonable when we don't rely on them. Problems come up when we want to keep the comments, the line breaks and whitespaces are removed by the lexer from the input string, what is left is not enough to determine whether a comment belongs to a specific token or not. I haven't read books and theories about parsing with comments, I am not going to, there must be a solution accessible via reasoning and thinking based on what I have gottten at present. It's easy to parse the Nginx file without any library, and in the tokenisation period you can easily decide where to place the comments. But it's hard when tokenisation is not up to you, in that case, you have to dive deep into the library. It seems to me, that the Chevrotain document does not expose the API of lexer manipulation.</p>
<p>The Chevrotain is good, really, it's fast, and not so hard to get going. The problem of comment drives me to read all its documents, it give me a feeling that the library is full of hackings, there are rules, and overridings of rules, documented, and undocumented, wow, a lot of surprises. But overall, it's benificial to get familiar with a library well made, but that will require me to look beyond the document, to look directly into the scary source.</p>
<p>One thing that puzzles me is that Javascript can make a method on the fly if provided with the name of the method, by means of passing a string to it. It's possible, it's dynamic typing language, but I can't imagine how to implement it, it's pure magic to me. Chevrotain is full of magic I don't understand. But now I just take it as it is, and focus on the problem I want to solve.</p>
<p>Please note that this article may not worth your time, because it's context-specific, and I just dump everything I think during my exploration of the library, the content is not organized into one direction, it's about everything that occurs to me, I have to write to sort them out.</p>
<h2 id="caveat-take-care-of-the-order-of-token-patterns" tabindex="-1">Caveat: take care of the order of token patterns</h2>
<p>Allow me to start with a case that is not Chevrotain related, it's perhaps a common mistake when tokenizing</p>
<pre class="one-piece"><code>{
        image: '\n  worker_connections  4096',
        startOffset: 244,
        endOffset: 270,
        startLine: 11,
        endLine: 12,
        startColumn: 9,
        endColumn: 26,
        tokenTypeIdx: 9,
        tokenType: {
          name: 'Literal',
          PATTERN: /[^{};]+/,
          tokenTypeIdx: 9,
          CATEGORIES: [],
          categoryMatches: [],
          categoryMatchesMap: {},
          isParent: false
        }
      },
      {
        image: ';',
        startOffset: 271,
        endOffset: 271,
        startLine: 12,
        endLine: 12,
        startColumn: 27,
        endColumn: 27,
        tokenTypeIdx: 5,
        tokenType: {
          name: 'Semicolon',
          PATTERN: /;/,
          tokenTypeIdx: 5,
          CATEGORIES: [],
          categoryMatches: [],
          categoryMatchesMap: {},
          isParent: false
        }
      },
</code></pre>
<p>When lexing the following block, I expect the result to be <code>worker_connection, 4096, semicolon</code></p>
<pre class="one-piece"><code>events {
  worker_connections  4096;  ## Default: 1024
}
</code></pre>
<p>The patten vector is:</p>
<pre class="one-piece"><code>[Literal(/[^{};]+/), WhiteSpace]
</code></pre>
<p>The problem is that <code>Literal</code> will match spaces,  to avoid that, the patten should be rewritten to <code>/[^{};\t ]+/</code>, but it overlaps with the <code>WhiteSpace</code>, the solution is to put <code>WhiteSpace</code> before <code>Literal</code>, but that is not good enough, the best is to specify exactly what we want as in <code>Literal</code>, not what we don't want. It's my laziness that led to the mistake. But I am not going to consider the case where strings are wrapped by quotes with space within, as a matter of fact, in Nginx files, a string can exists without quotes, there are lots of strange characters for Nginx regular matching which add to the difficulty of enumerating all possible characters, so for now, I just swap the positions of these two pattern.</p>
<p>Later it turns out that if if there's no white space preceeding a consecutive spaced-separated literals, those literals will be recognized as one literal. Terrible mistake.</p>
<p>I end up with this:</p>
<pre class="one-piece"><code>const SingleQuotedLiteral = createToken({ name: "single quote", pattern: /'[^']*'/ });
const DoubleQuoteLiteral = createToken({ name: "double quote", pattern: /"[^"]*"/ });
const Literal = createToken({
    name: "Literal", pattern: /[^{}; \t]+/
});
</code></pre>
<h2 id="parsing-the-comment" tabindex="-1">Parsing the comment</h2>
<p>Take a look at <a href="https://github.com/Chevrotain/chevrotain/blob/master/examples/grammars/json/json_with_comments.js#L20">https://github.com/Chevrotain/chevrotain/blob/master/examples/grammars/json/json_with_comments.js#L20</a> , it took me a long time to understand it, when I did, I thought the design is really smart. I use the principle revealed in the example above, what differs with my aim is that I also collect inline comments, which appear at the end of a statement.</p>
<h3 id="the-syntax-of-a-comment" tabindex="-1">The syntax of a comment</h3>
<p>Comments can't be discarded(marked as LEXER.SKIPPED), they must be treated as tokens. A comment either occupies one entire line, or appears at the end of the line. A token that is not a comment is surrounded by comments in the following format:</p>
<pre class="one-piece"><code>    # multiple lined standalone comments
     token # inline comment
</code></pre>
<p>It's easy to collect comments before a token, but hard to get the comment after a token, you can't tell if the comment belongs to the non-comment token before it, unless you look ahead and make sure the comment is in the same line with this non-comment token</p>
<h3 id="dont-skip-whitespaces" tabindex="-1">Don't skip whitespaces</h3>
<p>As the last section suggests, we should tell a standalone comment apart from an inline comment. But how? Without meta information, each comments is no more than a regular token surroundred by other regular tokens. My solution is to preserve the context of the comments, the context is nothing but the surrounding of whitespaces and newlines, to do that, I must not skip them.</p>
<h3 id="skip-the-comments-first-add-them-back-later" tabindex="-1">Skip the comments first, add them back later</h3>
<p>The solution is to make use of Chevrotain's two undocumented functions, <code>LA</code>, short for lookahead, and <code>cstPostTerminal</code>, which is called each time a terminal is parsed. OOP magnifies the sense of hacking in this case, as they are hook functions silently executed if we have no knowledge of their existence. I have no idea how to implement such mechanism withou OOP --- maybe by following the driver paradigm, using traits? Back to this later.</p>
<p>Let me just show you the code, I wrote a lot of comments on it.</p>
<pre class="one-piece"><code>    // from the source code of chevrotain:
    //
    // skips a token and returns the next token
    // SKIP_TOKEN(this: MixedInParser): IToken {
    //     if (this.currIdx &lt;= this.tokVector.length - 2) {
    //         this.consumeToken()
    //         return this.LA(1)
    //     } else {
    //         return END_OF_FILE
    //     }
    // }
    //
    // tokens marked as `lexer.SKIPPED` are absent in the cstPostTerminal process, in fact, they are discarded by the lexer,
    // in another word, the Parse has no information about those tokens,
    // we want to keep comments, so we don't mark them as `lex.SKIPPED`
    LA(howMuch: any) {
        // what happens here is to instruct the Parser(the base class that basically is a black box)
        //  that when it looks ahead for tokens(every kind of tokens), if it accidentally encounters Comment tokens,
        // it should simply walk past by calling `consumeToken`, which increase the token index. The original way `LA` behaves is to return whatever it sees.
        //
        //      consumeToken(this: MixedInParser) {
        //         this.currIdx++
        //      }
        //
        // Just pass by, don't do anything, but the "consumed" tokens are still there in the vector
        let t;
        while ((t = super.LA(howMuch)) &amp;&amp;
            (tokenMatcher(t, Comment) || tokenMatcher(t, WhiteSpace) || tokenMatcher(t, NewLine))) {
            super.consumeToken();
        }
        return super.LA(howMuch)
    }

    // Chevrotain source: packages/chevrotain/src/parse/parser/traits/tree_builder.ts:207
    //
    //      cstPostTerminal(
    //          this: MixedInParser,
    //          key: string,
    //          consumedToken: IToken
    //      ): void {
    //          const rootCst = this.CST_STACK[this.CST_STACK.length - 1]
    //          addTerminalToCst(rootCst, consumedToken, key)
    //          // This is only used when **both** error recovery and CST Output are enabled.
    //          this.setNodeLocationFromToken(rootCst.location!, &lt;any&gt;consumedToken)
    //      }
    //
    // The original `cstPostTerminal` is to add the terminal to CST, we twist it to add comments back to CST
    cstPostTerminal(key: any, consumedToken: any) {
        super.cstPostTerminal(key, consumedToken);
        // look behind for comments, the token stream looks like this:
        //
        //      token(space)comment(\n)
        //      comment(\n)comment(\n)token*(space)comment(\n)
        //
        // To correctly recognize the trailing comment, we don't mark anything as lex.SKIPPED,
        // let the parser decide which one to discard, the lexer's job is simply split the input into tokens
        // ------------
        // look for the trailing comment
        // the next position is reserved for traiing commnet
        // if it does not exist, use an Empty token instead
        //      {
        //        name: 'Empty',
        //        tokenTypeIdx: 12,
        //        CATEGORIES: [],
        //        categoryMatches: [],
        //        categoryMatchesMap: {},
        //        isParent: false
        //      }
        let lookAheadIdx = 1;
        let tokenAhead = super.LA(lookAheadIdx);
        while (tokenMatcher(tokenAhead, WhiteSpace)) {
            lookAheadIdx++;
            tokenAhead = super.LA(lookAheadIdx);
        }
        if (tokenMatcher(tokenAhead, Comment)) {
            super.cstPostTerminal(key, tokenAhead);
        } else {
            super.cstPostTerminal(key, Empty);
        }
        // look for comments before current token;
        let lookBehindIdx = -1;
        let prevToken = super.LA(lookBehindIdx);
        let prevComment;
        // state machine
        let lookingFor = 1; // 1 means comment, 2 means a regular token
        while (true) {
            if (tokenMatcher(prevToken, WhiteSpace)) {
                if (lookingFor === 2) {
                    // looking for a regular token, and encounter a whitespace, good, nothing to do here, go on
                } else if (lookingFor === 1) {
                    // else we are looking for a comment, it's still possible to encounter a whitespace
                }
            } else if (tokenMatcher(prevToken, NewLine)) {
                if (lookingFor === 2) {
                    // if we are looking for a regular token, but encounter a newline,
                    // then we should call off the action and look for another comment
                    lookingFor = 1;
                    // and consume the prevToken
                    super.cstPostTerminal(key, prevComment);
                } else {
                    // looking for a comment, it's ok to run into a newline
                }
                // then include the newlines to preserve format
                super.cstPostTerminal(key, prevToken);
            } else if (tokenMatcher(prevToken, Comment)) {
                if (lookingFor === 1) {
                    // stage the comment, don't consume it, wait until we are sure it's a stand alone comment
                    prevComment = prevToken;
                    lookingFor = 2;
                } else if (lookingFor === 2) {
                    // looking for regular tokes, but encounter a comment, we can safely consume the previous comment
                    super.cstPostTerminal(key, prevComment);
                    // looking for next comment
                    lookingFor = 1;
                }
            }
            // it's a regular token
            else {
                if (lookingFor === 2) {
                    // don't eat the previous comment
                    break;
                } else {
                    // we are looking for a comment, but encounter a regular token, that means there is no comment between these two tokens,
                    // then we should break
                    break;
                }
            }
            lookBehindIdx--;
            prevToken = super.LA(lookBehindIdx)
        }
    }
}
</code></pre>
<h3 id="formatter" tabindex="-1">Formatter</h3>
<p><s>Writing a formatter is relatively simpler by following the recursive descent parsing method.</s></p>
<pre class="one-piece"><code>http {
----server_names_hash_bucket_size 128; # this seems to be required for some vhosts
----server { # php/fastcgi
--------listen 80;
--------server_name domain1.com www.domain1.com;
--------access_log logs/domain1.access.log main;
--------root html;
--------location ~ \.php$ {
------------fastcgi_pass 127.0.0.1:1025;
--------}
--------location / {
------------fastcgi_pass 127.0.0.1:1025;
--------}
----}
}
</code></pre>
<p><s>But not that simple: you have to align the words, but that is another subject.</s></p>
<p>I was wrong, formatters are extremely hard to write, the formatter I wrote is the formatter of the simplest form. Take a look at this: <a href="https://news.ycombinator.com/item?id=22706242">https://news.ycombinator.com/item?id=22706242</a></p>
<p>But this post is about parsing. Formatting is another subject for the next post.</p>

      </div>
      <hr>
      <div class="content-tail">
        
        <p>
          For comments, please send me
          <a href="mailto:z6bxeq7qnskquw7msrvat328e6@protonmail.com"> an email</a>.
        </p>

        
      </div>
      <footer><hr>
<p>Â©2022</p>

</footer>
    </div>

  </body>
</html>
